/* Generated by https://app.quicktype.io/ */

export interface EnkaAPIData {
  playerInfo: PlayerInfo;
  avatarInfoList: AvatarInfoList[];
  ttl: number;
  uid: string;
}

export interface AvatarInfoList {
  avatarId: number;
  propMap: { [key: string]: PropMap };
  fightPropMap: { [key: string]: number };
  skillDepotId: number;
  inherentProudSkillList: number[];
  skillLevelMap: { [key: string]: number };
  equipList: EquipList[];
  fetterInfo: FetterInfo;
  talentIdList?: number[];
  proudSkillExtraLevelMap?: { [key: string]: number };
}

export interface EquipList {
  itemId: number;
  reliquary?: Reliquary;
  flat: Flat;
  weapon?: Weapon;
}

export interface Flat {
  nameTextMapHash: string;
  setNameTextMapHash?: string;
  rankLevel: number;
  reliquaryMainstat?: ReliquaryMainstat;
  reliquarySubstats?: Stat[];
  itemType: ItemType;
  icon: string;
  equipType?: EquipType;
  weaponStats?: Stat[];
}

export enum EquipType {
  EquipBracer = "EQUIP_BRACER",
  EquipDress = "EQUIP_DRESS",
  EquipNecklace = "EQUIP_NECKLACE",
  EquipRing = "EQUIP_RING",
  EquipShoes = "EQUIP_SHOES",
}

export enum ItemType {
  ItemReliquary = "ITEM_RELIQUARY",
  ItemWeapon = "ITEM_WEAPON",
}

export interface ReliquaryMainstat {
  mainPropId: PropID;
  statValue: number;
}

export enum PropID {
  FightPropAttack = "FIGHT_PROP_ATTACK",
  FightPropAttackPercent = "FIGHT_PROP_ATTACK_PERCENT",
  FightPropBaseAttack = "FIGHT_PROP_BASE_ATTACK",
  FightPropChargeEfficiency = "FIGHT_PROP_CHARGE_EFFICIENCY",
  FightPropCritical = "FIGHT_PROP_CRITICAL",
  FightPropCriticalHurt = "FIGHT_PROP_CRITICAL_HURT",
  FightPropDefense = "FIGHT_PROP_DEFENSE",
  FightPropDefensePercent = "FIGHT_PROP_DEFENSE_PERCENT",
  FightPropElementMastery = "FIGHT_PROP_ELEMENT_MASTERY",
  FightPropFireAddHurt = "FIGHT_PROP_FIRE_ADD_HURT",
  FightPropHP = "FIGHT_PROP_HP",
  FightPropHPPercent = "FIGHT_PROP_HP_PERCENT",
  FightPropHealAdd = "FIGHT_PROP_HEAL_ADD",
  FightPropWaterAddHurt = "FIGHT_PROP_WATER_ADD_HURT",
}

export interface Stat {
  appendPropId: PropID;
  statValue: number;
}

export interface Reliquary {
  level: number;
  mainPropId: number;
  appendPropIdList: number[];
}

export interface Weapon {
  level: number;
  promoteLevel: number;
  affixMap: { [key: string]: number };
}

export interface FetterInfo {
  expLevel: number;
}

export interface PropMap {
  type: number;
  ival: string;
  val?: string;
}

export interface PlayerInfo {
  nickname: string;
  level: number;
  worldLevel: number;
  nameCardId: number;
  finishAchievementNum: number;
  towerFloorIndex: number;
  towerLevelIndex: number;
  showAvatarInfoList: ShowAvatarInfoList[];
  showNameCardIdList: number[];
  profilePicture: ProfilePicture;
}

export interface ProfilePicture {
  avatarId: number;
}

export interface ShowAvatarInfoList {
  avatarId: number;
  level: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toEnkaAPIData(json: string): EnkaAPIData {
    return cast(JSON.parse(json), r("EnkaAPIData"));
  }

  public static enkaAPIDataToJson(value: EnkaAPIData): string {
    return JSON.stringify(uncast(value, r("EnkaAPIData")), null, 2);
  }
}

function invalidValue(typ: any, val: any, key: any, parent: any = ""): never {
  const prettyTyp = prettyTypeName(typ);
  const parentText = parent ? ` on ${parent}` : "";
  const keyText = key ? ` for key "${key}"` : "";
  throw Error(
    `Invalid value${keyText}${parentText}. Expected ${prettyTyp} but got ${JSON.stringify(
      val
    )}`
  );
}

function prettyTypeName(typ: any): string {
  if (Array.isArray(typ)) {
    if (typ.length === 2 && typ[0] === undefined) {
      return `an optional ${prettyTypeName(typ[1])}`;
    } else {
      return `one of [${typ
        .map((a) => {
          return prettyTypeName(a);
        })
        .join(", ")}]`;
    }
  } else if (typeof typ === "object" && typ.literal !== undefined) {
    return typ.literal;
  } else {
    return typeof typ;
  }
}

function jsonToJSProps(typ: any): any {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p: any) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p: any) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(
  val: any,
  typ: any,
  getProps: any,
  key: any = "",
  parent: any = ""
): any {
  function transformPrimitive(typ: string, val: any): any {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key, parent);
  }

  function transformUnion(typs: any[], val: any): any {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val, key, parent);
  }

  function transformEnum(cases: string[], val: any): any {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(
      cases.map((a) => {
        return l(a);
      }),
      val,
      key,
      parent
    );
  }

  function transformArray(typ: any, val: any): any {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue(l("array"), val, key, parent);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val: any): any {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue(l("Date"), val, key, parent);
    }
    return d;
  }

  function transformObject(
    props: { [k: string]: any },
    additional: any,
    val: any
  ): any {
    if (val === null || typeof val !== "object" || Array.isArray(val)) {
      return invalidValue(l(ref || "object"), val, key, parent);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key)
        ? val[key]
        : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, key, ref);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key, ref);
      }
    });
    return result;
  }

  if (typ === "any") return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val, key, parent);
  }
  if (typ === false) return invalidValue(typ, val, key, parent);
  let ref: any = undefined;
  while (typeof typ === "object" && typ.ref !== undefined) {
    ref = typ.ref;
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === "object") {
    return typ.hasOwnProperty("unionMembers")
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty("arrayItems")
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty("props")
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val, key, parent);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== "number") return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
  return transform(val, typ, jsToJSONProps);
}

function l(typ: any) {
  return { literal: typ };
}

function a(typ: any) {
  return { arrayItems: typ };
}

function u(...typs: any[]) {
  return { unionMembers: typs };
}

function o(props: any[], additional: any) {
  return { props, additional };
}

function m(additional: any) {
  return { props: [], additional };
}

function r(name: string) {
  return { ref: name };
}

const typeMap: any = {
  EnkaAPIData: o(
    [
      { json: "playerInfo", js: "playerInfo", typ: r("PlayerInfo") },
      {
        json: "avatarInfoList",
        js: "avatarInfoList",
        typ: a(r("AvatarInfoList")),
      },
      { json: "ttl", js: "ttl", typ: 0 },
      { json: "uid", js: "uid", typ: "" },
    ],
    false
  ),
  AvatarInfoList: o(
    [
      { json: "avatarId", js: "avatarId", typ: 0 },
      { json: "propMap", js: "propMap", typ: m(r("PropMap")) },
      { json: "fightPropMap", js: "fightPropMap", typ: m(3.14) },
      { json: "skillDepotId", js: "skillDepotId", typ: 0 },
      {
        json: "inherentProudSkillList",
        js: "inherentProudSkillList",
        typ: a(0),
      },
      { json: "skillLevelMap", js: "skillLevelMap", typ: m(0) },
      { json: "equipList", js: "equipList", typ: a(r("EquipList")) },
      { json: "fetterInfo", js: "fetterInfo", typ: r("FetterInfo") },
      { json: "talentIdList", js: "talentIdList", typ: u(undefined, a(0)) },
      {
        json: "proudSkillExtraLevelMap",
        js: "proudSkillExtraLevelMap",
        typ: u(undefined, m(0)),
      },
    ],
    false
  ),
  EquipList: o(
    [
      { json: "itemId", js: "itemId", typ: 0 },
      { json: "reliquary", js: "reliquary", typ: u(undefined, r("Reliquary")) },
      { json: "flat", js: "flat", typ: r("Flat") },
      { json: "weapon", js: "weapon", typ: u(undefined, r("Weapon")) },
    ],
    false
  ),
  Flat: o(
    [
      { json: "nameTextMapHash", js: "nameTextMapHash", typ: "" },
      {
        json: "setNameTextMapHash",
        js: "setNameTextMapHash",
        typ: u(undefined, ""),
      },
      { json: "rankLevel", js: "rankLevel", typ: 0 },
      {
        json: "reliquaryMainstat",
        js: "reliquaryMainstat",
        typ: u(undefined, r("ReliquaryMainstat")),
      },
      {
        json: "reliquarySubstats",
        js: "reliquarySubstats",
        typ: u(undefined, a(r("Stat"))),
      },
      { json: "itemType", js: "itemType", typ: r("ItemType") },
      { json: "icon", js: "icon", typ: "" },
      { json: "equipType", js: "equipType", typ: u(undefined, r("EquipType")) },
      {
        json: "weaponStats",
        js: "weaponStats",
        typ: u(undefined, a(r("Stat"))),
      },
    ],
    false
  ),
  ReliquaryMainstat: o(
    [
      { json: "mainPropId", js: "mainPropId", typ: r("PropID") },
      { json: "statValue", js: "statValue", typ: 3.14 },
    ],
    false
  ),
  Stat: o(
    [
      { json: "appendPropId", js: "appendPropId", typ: r("PropID") },
      { json: "statValue", js: "statValue", typ: 3.14 },
    ],
    false
  ),
  Reliquary: o(
    [
      { json: "level", js: "level", typ: 0 },
      { json: "mainPropId", js: "mainPropId", typ: 0 },
      { json: "appendPropIdList", js: "appendPropIdList", typ: a(0) },
    ],
    false
  ),
  Weapon: o(
    [
      { json: "level", js: "level", typ: 0 },
      { json: "promoteLevel", js: "promoteLevel", typ: 0 },
      { json: "affixMap", js: "affixMap", typ: m(0) },
    ],
    false
  ),
  FetterInfo: o([{ json: "expLevel", js: "expLevel", typ: 0 }], false),
  PropMap: o(
    [
      { json: "type", js: "type", typ: 0 },
      { json: "ival", js: "ival", typ: "" },
      { json: "val", js: "val", typ: u(undefined, "") },
    ],
    false
  ),
  PlayerInfo: o(
    [
      { json: "nickname", js: "nickname", typ: "" },
      { json: "level", js: "level", typ: 0 },
      { json: "worldLevel", js: "worldLevel", typ: 0 },
      { json: "nameCardId", js: "nameCardId", typ: 0 },
      { json: "finishAchievementNum", js: "finishAchievementNum", typ: 0 },
      { json: "towerFloorIndex", js: "towerFloorIndex", typ: 0 },
      { json: "towerLevelIndex", js: "towerLevelIndex", typ: 0 },
      {
        json: "showAvatarInfoList",
        js: "showAvatarInfoList",
        typ: a(r("ShowAvatarInfoList")),
      },
      { json: "showNameCardIdList", js: "showNameCardIdList", typ: a(0) },
      {
        json: "profilePicture",
        js: "profilePicture",
        typ: r("ProfilePicture"),
      },
    ],
    false
  ),
  ProfilePicture: o([{ json: "avatarId", js: "avatarId", typ: 0 }], false),
  ShowAvatarInfoList: o(
    [
      { json: "avatarId", js: "avatarId", typ: 0 },
      { json: "level", js: "level", typ: 0 },
    ],
    false
  ),
  EquipType: [
    "EQUIP_BRACER",
    "EQUIP_DRESS",
    "EQUIP_NECKLACE",
    "EQUIP_RING",
    "EQUIP_SHOES",
  ],
  ItemType: ["ITEM_RELIQUARY", "ITEM_WEAPON"],
  PropID: [
    "FIGHT_PROP_ATTACK",
    "FIGHT_PROP_ATTACK_PERCENT",
    "FIGHT_PROP_BASE_ATTACK",
    "FIGHT_PROP_CHARGE_EFFICIENCY",
    "FIGHT_PROP_CRITICAL",
    "FIGHT_PROP_CRITICAL_HURT",
    "FIGHT_PROP_DEFENSE",
    "FIGHT_PROP_DEFENSE_PERCENT",
    "FIGHT_PROP_ELEMENT_MASTERY",
    "FIGHT_PROP_FIRE_ADD_HURT",
    "FIGHT_PROP_HP",
    "FIGHT_PROP_HP_PERCENT",
    "FIGHT_PROP_HEAL_ADD",
    "FIGHT_PROP_WATER_ADD_HURT",
  ],
};
